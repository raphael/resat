= Resat - Web scripting for the masses

= DESCRIPTION

== Synopsis

Resat is a script engine which allows grouping web requests into <b>scenarios</b>.
A scenario consists of serie of HTTP requests called <b>steps</b>.
Each step may be associated with <b>guards</b> and/or <b>filters</b>.

* Guards keep making the same request until the response header and/or body
  satisfy(ies) certain conditions.

* Filters validate the response and may save some of its elements in variables.
  Variables can be used to define requests, guards and filters.

Scenarios are defined as YAML documents that must adhere to the Kwalify
schemas defined in <tt>schemas/scenarios.yaml</tt>. See the comments in this
file for additional information.

Resat is configured through a YAML configuration file which defines
default values that applies to all requests including the host name,
base url, whether to use SSL, common headers and body parameters and
optionally a username and password to be used with basic authentication.
This configuration file is located in <tt>config/resat.yaml</tt> by default.

== Why resat?

There are two main use cases for resat:

 1. Scripting: Resat can be used to chaing together a serie of REST API calls
    that can be used to perform repetitive tasks.

 2. API testing: For REST API implementors, resat is the ideal automated
    regression tool. This is the tool we use at RightScale to test our APIs.

== How to use

resat can be used as a ruby library or as an application. Using it as library
involves instantiating the engine and calling the 'run' method:

  require 'resat'

  options = OpenStruct.new
  options.verbose     = false
  options.quiet       = false
  options.norecursion = false
  options.loglevel    = 'info'
  options.logfile     = 'resat.log'
  options.configfile  = 'config/resat.yaml'
  options.schemasdir  = 'schemas'

  Resat::Log.init(options)
  engine = Resat::Engine.new(options)
  engine.run

  if engine.succeeded?
    puts engine.summary.dark_blue
  else
    puts engine.summary.dark_red
  end
  puts "#{engine.requests_count} request(s)."
  puts "#{engine.ignored_count} scenario(s) ignored."
  puts "#{engine.skipped_count} YAML file(s) skipped."

See the examples and usage sections below for using resat as an application.

== Examples

Run the scenario defined in scenario.yaml:

  resat scenario.yaml

Execute scenarios defined in the 'scenarios' directory and its
sub-directories:

  resat scenarios

Only execute the scenarios defined in the current directory, do not execute
scenarios found in sub-directories:

  resat -n .

== Usage

  resat [options] target

  For help use: resat -h

== Options

 -h, --help Display help message
 -v, --version Display version, then exit
 -q, --quiet Output as little as possible, override verbose
 -V, --verbose Verbose output
 -n, --norecursion Don't run scenarios defined in sub-directories
 -d, --define NAME:VAL Define global variable (can appear multiple times,
                       escape ':' with '::')
 -f, --failonerror Stop resat from continuing to run if an error occurs
 -c, --config PATH Config file path (config/resat.yaml by default)
 -s, --schemasdir DIR Path to schemas directory (schemas/ by default)
 -l, --loglevel LVL Log level: debug, info, warn, error (info by default)
 -F, --logfile PATH Log file path (resat.log by default)

= INSTALLATION

Run the following command from the current folder to be able to run resat from
anywhere:

  sudo ln -s `pwd`/resat.rb /usr/local/bin/resat

= DEVELOPMENT

== Source

The source code of Resat is available via Git:

  $ git clone git://github.com/raphael/resat.git

* http://github.com/raphael/resat.git

== Dependencies

resat relies on Kwalify for validating YAML files:

  $ sudo gem install kwalify
